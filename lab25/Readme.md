# Звіт з лабораторної роботи №25
**Тема:** Інтеграція патернів (підготовка до екзамену).
**Мета:** Розробити систему, що демонструє взаємодію між компонентами, які реалізують патерни Factory Method, Singleton, Strategy та Observer, а також переконатися в коректності їхньої спільної роботи.

---

## 1. Архітектура системи та ролі патернів

В рамках цієї роботи було створено комплексну систему обробки та логування даних. Головна мета — показати, як твірні та поведінкові патерни можуть безконфліктно працювати разом.

* **Factory Method (`LoggerFactory`)**: Відповідає за створення конкретних об'єктів логування (`ConsoleLogger` або `FileLogger`). Дозволяє системі працювати з абстракцією `ILogger`, приховуючи логіку створення конкретних екземплярів.
* **Singleton (`LoggerManager`)**: Гарантує, що в усій програмі існує лише одна глобальна точка доступу до системи логування. Будь-який клас (наприклад, спостерігач) може викликати `LoggerManager.Instance.LogData()`, не створюючи нових об'єктів логера.
* **Strategy (`IDataProcessorStrategy`)**: Інкапсулює алгоритми перетворення даних (`EncryptDataStrategy` для шифрування та `CompressDataStrategy` для стиснення). Дозволяє класу `DataContext` динамічно змінювати алгоритм обробки під час виконання програми.
* **Observer (`DataPublisher` та події C#)**: Забезпечує слабку зв'язність між процесом обробки даних та їх логуванням. Коли дані оброблені, `DataPublisher` генерує подію `DataProcessed`. Спостерігач `ProcessingLoggerObserver` реагує на неї та передає результат у логер.

---

## 2. Результати виконання сценаріїв (Метод Main)

Програма успішно демонструє три ключові сценарії взаємодії патернів:

### Сценарій 1: Повна інтеграція
* **Дія:** Встановлено `ConsoleLoggerFactory` та стратегію шифрування (`EncryptDataStrategy`).
* **Результат:** Дані успішно зашифровано. `DataPublisher` викликав подію, яку перехопив `ProcessingLoggerObserver` і, використовуючи Singleton-менеджер, вивів зашифрований результат у консоль.

### Сценарій 2: Динамічна зміна логера
* **Дія:** Під час виконання програми (runtime) фабрику в `LoggerManager` змінено на `FileLoggerFactory`. Стратегія залишилася попередньою.
* **Результат:** Наступна обробка тих самих даних успішно відбулася, але результат цього разу було записано у файл `system_log.txt` (завдяки зміні фабрики), що підтверджує гнучкість системи логування.

### Сценарій 3: Динамічна зміна стратегії
* **Дія:** Алгоритм обробки в `DataContext` динамічно замінено на `CompressDataStrategy`.
* **Результат:** Обробка даних відбулася за новим алгоритмом (стиснення). Спостерігач коректно зафіксував зміну і передав новий результат поточному логеру (файловому). 

---

## 3. Висновки

Інтеграція декількох патернів проєктування дозволяє створювати модульні, легко тестовані та масштабовані додатки. 
Завдяки правильному розподілу відповідальності:
1. **Factory Method** створює об'єкти;
2. **Singleton** контролює єдиний доступ;
3. **Strategy** дозволяє змінювати поведінку (алгоритми) на льоту;
4. **Observer** організовує асинхронне сповіщення компонентів.

Зміна однієї частини системи (наприклад, перемикання з виводу в консоль на файл або зміна логіки шифрування) жодним чином не впливає на інші компоненти. Це підтверджує дотримання принципів SOLID (зокрема, Open/Closed Principle та Dependency Inversion Principle) і є ключем до побудови надійної архітектури.

![Скріншот виконання](image-1.png)